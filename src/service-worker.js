/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';
import Dexie from 'dexie';

// Any other custom service worker logic can go here.
import './push';

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    } // If this is a URL that starts with /_, skip.

    if (url.pathname.startsWith('/_')) {
      return false;
    } // If this looks like a URL for a resource, because it contains // a file extension, skip.

    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    } // Return true to signal that we want to use the handler.

    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html'),
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) =>
    url.origin === self.location.origin && url.pathname.endsWith('.png'), // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  }),
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

const db = new Dexie('list');
db.version(1).stores({
  items: '&id, amount, unit, name',
  modification: '&id, type, data',
});

async function applyModifications() {
  const modifications = await db.table('modification').toArray();
  modifications.forEach(async (modification) => {
    // eslint-disable-next-line default-case
    switch (modification.type) {
      case 'create':
        delete modification.data.id;
        await fetch('/item', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(modification.data),
        });
        break;
      case 'update':
        await fetch(`/item/${modification.data.id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(modification.data),
        });
        break;
      case 'delete':
        await fetch(`/item/${modification.data.id}`, {
          method: 'DELETE',
          body: JSON.stringify(modification.id),
        });
        break;
    }
    if (
      modification.data &&
      modification.data.id &&
      modification.data.id.toString().startsWith('l')
    ) {
      await db.table('item').delete(modification.data.id);
    }
    await db.table('modification').delete(modification.id);
  });
}

self.addEventListener('fetch', async (event) => {
  if (event.request.url.includes('/item')) {
    // eslint-disable-next-line default-case
    switch (event.request.method) {
      case 'GET':
        event.respondWith(
          (async () => {
            let data = [];
            let isOffline = false;
            if (navigator.onLine) {
              try {
                const response = await fetch('/item');
                data = await response.json();
              } catch (e) {
                isOffline = true;
              }
            } else {
              isOffline = true;
            }
            if (isOffline) {
              data = await db.table('items').toArray();
            } else {
              applyModifications();
              db.table('items').clear();
              db.table('items').bulkAdd(data);
            }
            return new Response(JSON.stringify(data));
          })(),
        );
        break;
      case 'POST':
      case 'PUT':
        event.respondWith(
          (async () => {
            const body = await event.request.json();
            let isOffline = false;
            let data = null;
            if (navigator.onLine) {
              try {
                const response = await fetch(event.request);
                data = await response.json();
              } catch (e) {
                isOffline = true;
              }
            } else {
              isOffline = true;
            }

            if (isOffline) {
              data = { ...body };
              if (!data.id) {
                const mods = await db.table('modification').toArray();
                const localIds = mods
                  .map((mod) => mod.id.toString())
                  .filter((mod) => mod.startsWith('l'))
                  .map((mod) => mod.substring(1, mod.length))
                  .map((mod) => parseInt(mod, 10));
                let nextId = 1;
                if (localIds.length > 0) {
                  nextId = Math.max(...localIds) + 1;
                }
                data.id = `l${nextId}`;
              }
              db.table('modification').put({
                id: data.id,
                type: data.id.toString().startsWith('l') ? 'create' : 'update',
                data,
              });
              db.table('items').put(data, data.id);
            } else {
              applyModifications();
              db.table('items').put(data);
            }
            return new Response(JSON.stringify(data));
          })(),
        );
        break;
      case 'DELETE':
        event.respondWith(
          (async () => {
            const id = event.request.url.split('/').pop();
            let isOffline = false;
            if (navigator.onLine) {
              try {
                await fetch(`/item/${id}`, {
                  method: 'DELETE',
                });
              } catch (e) {
                isOffline = true;
              }
            } else {
              isOffline = true;
            }
            if (isOffline) {
              if (id.toString().startsWith('l')) {
                db.table('modification').delete(id);
              } else {
                db.table('modification').put({
                  id,
                  type: 'delete',
                });
              }
              db.table('items').delete(id);
            } else {
              applyModifications();
              db.table('items').delete(id);
            }
            return new Response();
          })(),
        );
        break;
    }
  }
});
